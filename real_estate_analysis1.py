# -*- coding: utf-8 -*-
"""Real_Estate_Analysis1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15WsZx4fVsNrvKvd9wgT32qXMHPCYnEaV
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import matplotlib.ticker as mtick
import warnings
warnings.filterwarnings('ignore')

from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_absolute_error, r2_score
from sklearn.ensemble import RandomForestRegressor
from sklearn.preprocessing import StandardScaler

#Asthetics
plt.style.use('default') # Reset to default style
sns.set_theme(style = 'whitegrid') # use seaborn's whitegrid style
sns.set_palette('viridis')

data = pd.read_csv('/content/kc_house_data.csv')

data.head()

data.shape

data.info()

# data preprocessing
data['date']= pd.to_datetime(data['date'])
data['month'] = data['date'].dt.month
data['year']  = data['date'].dt.year

# Create a price per square foot column
data['price_per_sqrt'] = data['price'] / data['sqft_living']

# Create a categorical variable for house age
current_year = 2015
data['house_age'] = current_year - data['yr_built']
data['age_category'] = pd.cut(data['house_age'],
                              bins = [0, 10, 20, 40, 60, 100, 200],
                              labels = ['0-10 years', '11-20 years', '21-40 years' ,
                                        '41-60 years', '61-100 years', '100+ years'])

data.head()

# Checking Missing values
print(data.isnull().sum())

data.describe() # Avg price of a house: 540,088

"""##Analysis for Buyers

### What are the most affordable areas(zip codes) in King county?
"""

zipcode_median_price = data.groupby('zipcode')['price'].median().sort_values()
#Get the top15 most affordable
affordable_zipcodes = zipcode_median_price.head(15)

#plotting the data
plt.figure(figsize=(12,6))
affordable_zipcodes.plot(kind = 'bar', color = 'skyblue')
plt.title('Affordable Top15 zipcodes in King County', fontsize = 16)
plt.xlabel('Zipcodes', fontsize = 12)
plt.ylabel('Median Price ($)', fontsize = 12)
plt.xticks(rotation = 45)

plt.tight_layout()

"""#### **Buyers Observations:**
- The most affordable areas in King County are concentrated in zipcodes like 98002, 98032, and 98030.
- First-time homebuyers should focus their search in these areas to find more budget-friendly options.
- These zipcodes offer entry points to the King County housing market with median prices significantly below the county average.

###2. How does house size (square footage) affect price, and what is the best value for money?
"""

# Scatterplot of house size Vs. price
plt.figure(figsize = (12,6))
sns.scatterplot(data = data, x='sqft_living', y = 'price', alpha = 0.5, hue = 'bedrooms', palette = 'pastel')
plt.title('House Size Vs. Price', fontsize =16)
plt.xlabel('House size(sqft)', fontsize =12)
plt.ylabel('Price($)', fontsize = 12)

# Caluculate price per Square foot by size range
data['sqft_range'] = pd.cut(data['sqft_living'],
                           bins=[0, 1000, 1500, 2000, 2500, 3000, 10000],
                           labels=['<1000', '1000-1500', '1500-2000',
                                   '2000-2500','2500-3000', '>3000'])

# Calculate median price per each sqft size range
price_per_sqft_by_size = data.groupby('sqft_range')['price_per_sqrt'].median().sort_values()

plt.figure(figsize = (12,6))
price_per_sqft_by_size.plot(kind = 'bar', color = 'lightgreen')
plt.title('Median Price per Square foot by House Size', fontsize = 16)
plt.xlabel('House Size Range (sqft)', fontsize = 12)
plt.ylabel('Median Price per Square Foot ($)', fontsize = 12)

"""#### **Buyers Observations:**
- There is a strong positive correlation between house size and price, but with significant variation.
- Smaller houses (<1000 sqft) have the highest price per square foot, making them less economical in terms of space.
- The best value for money appears to be in the 2000-2500 sqft range, where the price per square foot is lower than both smaller and larger homes.
- Very large homes (>3000 sqft) command premium prices per square foot, reflecting luxury amenities and locations.

### 3.How do property condition and age affect house prices?
"""

# Analyse House Price by Condition and Age

# a. Analyse price by condition
plt.figure(figsize = (12,6))
sns.boxplot(data = data, x = 'condition', y = 'price')
plt.title('House Price by Condition rating', fontsize = 16)
plt.xlabel(' Condition (1 =Poor, 5=Excellent)', fontsize = 12)
plt.ylabel('Price($)', fontsize = 12)
plt.grid(axis = 'y', linestyle = '--', alpha = 0.7),

# b. Analyse price by age
plt.figure('figsize = (18, 6)')
sns.boxplot(x='age_category', y='price', data = data)
plt.title('House Price by Age Category', fontsize=16)
plt.xlabel('House Age', fontsize=12)
plt.ylabel('Price($)', fontsize=12)
plt.xticks(rotation=45)
plt.grid(axis='y', linestyle = '--', alpha =0.7)

# Calculate House median price by condition rating and age category
condition_age_price = data.groupby(['condition','age_category'])['price'].median().unstack()

# Heat map
plt.figure(figsize=(14, 8))
sns.heatmap(condition_age_price, annot=True, fmt=',.0f', cmap='YlGnBu', linewidths=0.5)
plt.title('Median House Price by Condition and Age ($)', fontsize=16)
plt.xlabel('House Age', fontsize=12)
plt.ylabel('Condition Rating', fontsize=12)
plt.tight_layout()
plt.show()

"""#### **Buyers Observations:**
- Houses in excellent condition (rating 5) command significantly higher prices than those in poor condition.
- Newer homes (0-10 years) generally have higher prices regardless of condition.
- The sweet spot for value-conscious buyers appears to be houses in good condition (3-4) that are 21-60 years old.
- Very old homes (100+ years) in excellent condition can command premium prices, likely due to historical value and extensive renovations.

### 4. What is the impact of location features (waterfront, view) on property prices?
"""

# Analyse impact of waterfront on proprty price
plt.figure( figsize = (10,6))
sns.boxplot( data = data, x = 'waterfront', y = 'price' )
plt.title('Impact of Waterfront Location on House Price', fontsize = 16)
plt.xlabel('Waterfront Property (0=No, 1=Yes)', fontsize =12)
plt.ylabel('Price($)')
plt.grid(axis ='y', alpha =0.7, linestyle='--')

# Analyze impact of view quality
plt.figure(figsize=(12, 6))
sns.boxplot(x='view', y='price', data=data)
plt.title('Impact of View Quality on House Price', fontsize=16)
plt.xlabel('View Quality (0=None, 4=Excellent)', fontsize=12)
plt.ylabel('Price ($)', fontsize=12)
plt.grid(axis='y', linestyle='--', alpha=0.7)

# calculate price premium for waterfront and view
waterfront_premium = data.groupby('waterfront')['price'].median()
view_premium = data.groupby('view')['price'].median()

waterfront_premium_pct = ( waterfront_premium[1] / waterfront_premium[0] - 1)  * 100
view_premium_pct = ( view_premium[4] / view_premium[0] - 1 ) * 100

print(f" Waterfront Properties command a {waterfront_premium_pct:.1f}% premium over non waterfront properties")
print(f" Properties with excellent view command a {view_premium_pct:.1f}% premium over properties with no view")

"""## Analysis for Sellers

### 1. Which home features add the most value to a property?
"""

# Analyse the impact of various features on property price
# Create a correlation matrix

# Analyze the impact of various features on price
# Create correlation matrix
feature_cols = ['bedrooms', 'bathrooms', 'sqft_living', 'sqft_lot', 'floors',
                'waterfront', 'view', 'condition', 'grade', 'yr_built', 'yr_renovated']
correlation = data[feature_cols + ['price']].corr()['price'].sort_values(ascending=False)

# Plot correlation with price
plt.figure(figsize=(12, 8))
correlation.drop('price').plot(kind='bar', color='coral')
plt.title('Correlation of Home Features with Price', fontsize=16)
plt.xlabel('Features', fontsize=12)
plt.ylabel('Correlation Coefficient', fontsize=12)
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.tight_layout()
plt.show()

# Calculate the median price increase by bathroom count
bathroom_price = data.groupby(pd.cut(data['bathrooms'],
                                     bins = [1, 1.5, 2, 2.5, 3, 10],
                                     labels = ['1', '1.5', '2', '2.5', '3+']))['price'].median()

# Calculate bathroom percentage increase
bathroom_pct_increase = bathroom_price.pct_change() * 100

plt.figure(figsize=(12, 6))
bathroom_pct_increase.plot(kind='bar', color='teal')
plt.title('Percentage Increase in Price with Additional Bathrooms', fontsize=16)
plt.xlabel('Bathroom Count', fontsize=12)
plt.ylabel('% Increase in Median Price', fontsize=12)
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.tight_layout()
plt.show()

"""#### **Sellers Observations:**
- The features most strongly correlated with higher prices are grade (construction quality), square footage, and bathrooms.
- Each step up in grade rating dramatically increases property value, with homes rated 11+ commanding premium prices.
- Adding bathrooms has a significant impact on price, with the jump from 2 to 2.5 bathrooms showing the highest percentage increase.
- Waterfront location and view quality also significantly impact price, making these important selling points if your property has them.
- Sellers should highlight these high-value features in their listings to maximize sale price.

### 2. What is the optimal pricing strategy based on location (zipcode)?
"""

# Analyze price distribution by zipcode
# Get top 15 most expensive zipcodes
top_zipcodes = data.groupby('zipcode')['price'].median().sort_values(ascending=False).head(15)

plt.figure(figsize=(14, 7))
top_zipcodes.plot(kind='bar', color='darkred')
plt.title('15 Most Expensive Zipcodes in King County', fontsize=16)
plt.xlabel('Zipcode', fontsize=12)
plt.ylabel('Median House Price ($)', fontsize=12)
plt.xticks(rotation=45)
plt.grid(axis='y', linestyle='--', alpha=0.7)

# Calculate price distribution within zipcodes
# Select a few representative zipcodes (mix of high, medium, low price)
selected_zipcodes = [98004, 98039, 98112, 98052, 98115, 98118, 98032, 98002]
zipcode_data = data[data['zipcode'].isin(selected_zipcodes)]

plt.figure(figsize=(14, 8))
sns.violinplot(x='zipcode', y='price', data=zipcode_data, inner='quartile')
plt.title('Price Distribution by Selected Zipcodes', fontsize=16)
plt.xlabel('Zipcode', fontsize=12)
plt.ylabel('Price ($)', fontsize=12)
plt.grid(axis='y', linestyle='--', alpha=0.7)

# Calculate price per sqft by zipcode
price_per_sqft_by_zipcode = data.groupby('zipcode')['price_per_sqrt'].median().sort_values(ascending=False).head(15)

plt.figure(figsize=(14, 7))
price_per_sqft_by_zipcode.plot(kind='bar', color='darkgreen')
plt.title('Price per Square Foot by Zipcode (Top 15)', fontsize=16)
plt.xlabel('Zipcode', fontsize=12)
plt.ylabel('Median Price per Square Foot ($)', fontsize=12)
plt.xticks(rotation=45)
plt.grid(axis='y', linestyle='--', alpha=0.7)

"""#### **Sellers Observations:**
- Premium zipcodes like 98039 (Medina) and 98004 (Bellevue) command significantly higher prices, with median values above $1 million.
- Price distributions vary widely by zipcode, with high-end areas showing broader price ranges, suggesting more opportunity for premium pricing.
- Price per square foot analysis reveals where property space is most valuable, with waterfront and downtown areas commanding the highest rates.
- Sellers should price their homes based on zipcode-specific metrics rather than county-wide averages.
- In premium zipcodes, emphasizing luxury features can justify higher price points, while in moderate zipcodes, highlighting value relative to nearby areas may be more effective.

### 3. When is the best time to sell a house for maximum profit?
"""

monthly_median_price = data.groupby('month')['price'].median()
monthly_price_per_sqft = data.groupby('month')['price_per_sqrt'].median()
monthly_days_on_market = data.groupby('month')['id'].count()  # Using count as a proxy for market activity

# Plotting median price by month
plt.figure(figsize=(12, 6))
monthly_median_price.plot(kind='line', marker='o', color='red', linewidth=2)
plt.title('Median House Price by Month', fontsize=16)
plt.xlabel('Month', fontsize=12)
plt.ylabel('Median Price ($)', fontsize=12)
plt.xticks(range(1, 13), ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'])
plt.grid(True, alpha=0.3)



# Plotting price per square foot by month
plt.figure(figsize=(12, 6))
monthly_price_per_sqft.plot(kind='line', marker='o', color='purple', linewidth=2)
plt.title('Median Price per Square Foot by Month', fontsize=16)
plt.xlabel('Month', fontsize=12)
plt.ylabel('Median Price per Square Foot ($)', fontsize=12)
plt.xticks(range(1, 13), ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'])
plt.grid(True, alpha=0.3)

monthly_days_on_market

# Create a seller's market index (higher is better for sellers)
# Normalize each metric to 0-1 scale
norm_price = (monthly_median_price - monthly_median_price.min()) / (monthly_median_price.max() - monthly_median_price.min())
norm_volume = (monthly_days_on_market - monthly_days_on_market.min()) / (monthly_days_on_market.max() - monthly_days_on_market.min())
sellers_market_index = (norm_price * 0.7) + (norm_volume * 0.3)  # Weighted average

plt.figure(figsize=(12, 6))
sellers_market_index.plot(kind='bar', color='darkred')
plt.title('Best Months to Sell (Higher Values = Better Seller\'s Market)', fontsize=16)
plt.xlabel('Month', fontsize=12)
plt.ylabel("Seller's Market Index", fontsize=12)
plt.xticks(range(12), ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'], rotation=45)
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.tight_layout()
plt.show()

"""#### **Sellers Observations:**
- The spring and summer months (April-July) consistently show the highest median prices and price per square foot.
- June appears to be the optimal month to sell, with the highest seller's market index combining both price and sales volume advantages.
- April and May also show strong seller's market conditions, with high prices and increasing buyer activity.
- Winter months (November-January) show the weakest seller's market conditions and should be avoided if possible.
- If selling during off-peak months is necessary, sellers should consider offering incentives or adjusting prices to attract the smaller pool of winter buyers.

### 4. What renovations or improvements offer the best return on investement?
"""

# Analyse the impact of renovations on price
# Create a renovation indicator
data['is_renovated'] = data['yr_renovated'].apply(lambda x: 1 if x>0 else 0)
data['is_renovated']

# Compare prices of renovated vs. non-renovated homes
plt.figure(figsize=(10, 6))
sns.boxplot(x='is_renovated', y='price', data=data)
plt.title('Impact of Renovation on House Price', fontsize=16)
plt.xlabel('House Renovated (0=No, 1=Yes)', fontsize=12)
plt.ylabel('Price ($)', fontsize=12)
plt.grid(axis='y', linestyle='--', alpha=0.7)

# caluculate renovation premium by age category
renovation_premium = data.groupby(['age_category', 'is_renovated'])['price'].median().unstack()
renovation_premium['premium_pct'] = (renovation_premium[1] / renovation_premium[0] - 1) * 100

plt.figure(figsize=(12, 6))
renovation_premium['premium_pct'].plot(kind='bar', color='orange')
plt.title('Renovation Price Premium by House Age', fontsize=16)
plt.xlabel('House Age', fontsize=12)
plt.ylabel('Price Premium for Renovation (%)', fontsize=12)
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.tight_layout()
plt.show()

# Analyse basement impact on price
data['has_basement'] = data['sqft_basement'].apply(lambda x: 1 if x>0 else 0)

# Compare prices of homes with and without basements
plt.figure(figsize=(10, 6))
sns.boxplot(x='has_basement', y='price', data=data)
plt.title('Impact of Basement on House Price', fontsize=16)
plt.xlabel('Has Basement (0=No, 1=Yes)', fontsize=12)
plt.ylabel('Price ($)', fontsize=12)
plt.grid(axis='y', linestyle='--', alpha=0.7)

# Caluculate basement premium by house age
basement_premium = data.groupby(['sqft_range','has_basement'])['price'].median().unstack()
basement_premium['premium_pct'] = ( basement_premium[1] / basement_premium[0] - 1 * 100)

plt.figure(figsize=(12, 6))
basement_premium['premium_pct'].plot(kind='bar', color='brown')
plt.title('Basement Price Premium by House Size', fontsize=16)
plt.xlabel('House Size Range (sqft)', fontsize=12)
plt.ylabel('Price Premium for Basement (%)', fontsize=12)
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.tight_layout()
plt.show()

"""#### **Sellers Observations:**
- Renovated homes command a significant price premium over non-renovated homes, with median prices approximately 30-60% higher depending on age.
- The renovation premium is highest for older homes (41-100 years old), suggesting that updating these properties offers the best return on investment.
- Homes with basements also sell for higher prices, with the premium most significant for medium-sized homes (1500-2500 sqft).
- For smaller homes (<1500 sqft), adding a basement can increase value by 20-30%, making it a potentially worthwhile investment.
- Sellers should prioritize renovations for older homes and consider finishing basement space before listing to maximize sale price.

## Predictive Models

### 1. Price Prediction Model for Buyers

This model helps buyers estimate a fair price for properties based on key features, potentially identifying undervalued properties.
"""

# Devolpe a price prediction model for buyers
# Select features for the model

buyer_features = ['bedrooms', 'bathrooms', 'sqft_living', 'sqft_lot', 'floors',
                 'waterfront', 'view', 'condition', 'grade', 'yr_built',
                 'zipcode', 'lat', 'long']

# Prepare the data
X = data[buyer_features]
Y = data['price']

# Convert zipcode to dummy variables (one-hot encoding)
X = pd.get_dummies(X, columns=['zipcode'], drop_first=True)

# Split the data into training and testing sets
X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.2, random_state=42)

# Train a Random Forest Model
buyer_model = RandomForestRegressor(n_estimators=100, random_state=42)
buyer_model.fit(X_train, Y_train)

# Make predictions
Y_pred = buyer_model.predict(X_test)

# Evaluate the model
mae = mean_absolute_error(Y_test, Y_pred)
r2 = r2_score(Y_test, Y_pred)

print(f"Mean Absolute Error : $ {mae:,.2f}")
print(f"R_Squared: {r2:.4f}")

# Feature Importance
feature_importance = pd.DataFrame({
    'Feature': X.columns,
    'Importance': buyer_model.feature_importances_
     }).sort_values('Importance', ascending=False).head(10)

plt.figure(figsize=(12, 6))
sns.barplot(x='Importance', y='Feature', data=feature_importance)
plt.title('Top 10 Most Important Features for Price Prediction', fontsize=16)
plt.xlabel('Importance', fontsize=12)
plt.ylabel('Feature', fontsize=12)
plt.grid(axis='x', linestyle='--', alpha=0.7)
plt.tight_layout()
plt.show()

"""### 2. Optimal Pricing Model for Sellers

This model helps sellers determine the optimal listing price based on property features and market conditions to maximize sale price while minimizing time on market.
"""

# Develop an optimal pricing model for sellers
# For this model, we'll focus on features that sellers can control or highlight
seller_features = ['sqft_living', 'sqft_lot', 'bathrooms', 'bedrooms', 'floors',
                  'waterfront', 'view', 'condition', 'grade', 'yr_renovated',
                  'sqft_basement', 'yr_built', 'lat', 'long']

# Create additional features that might be relevant for sellers
data['total_rooms'] = data['bedrooms'] + data['bathrooms']
data['is_renovated'] = data['yr_renovated'].apply(lambda x: 1 if x > 0 else 0)
data['house_age'] = 2015 - data['yr_built']  # Dataset is from 2014-2015
data['has_basement'] = data['sqft_basement'].apply(lambda x: 1 if x > 0 else 0)

# Add these to seller features
seller_features.extend(['total_rooms','is_renovated', 'house_age', 'has_basement'])

X = data[seller_features]
y = data['price']

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Scale the features
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

# Train a Linear Regression model
seller_model = LinearRegression()
seller_model.fit(X_train_scaled, y_train)

#Make predictions
y_pred = seller_model.predict(X_test_scaled)

# Evaluate the model
mae = mean_absolute_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)

print(f"Mean Absolute Error: ${mae:,.2f}")
print(f"R-squared: {r2:.4f}")

# Analyze coefficients to understand feature impact on price
coefficients = pd.DataFrame({
    'Feature': X.columns,
    'Coefficient': seller_model.coef_
}).sort_values('Coefficient', ascending=False)

plt.figure(figsize=(12, 8))
sns.barplot(x='Coefficient', y='Feature', data=coefficients)
plt.title('Feature Impact on House Price', fontsize=16)
plt.xlabel('Coefficient (Impact on Price)', fontsize=12)
plt.ylabel('Feature', fontsize=12)
plt.grid(axis='x', linestyle='--', alpha=0.7)
plt.tight_layout()
plt.show()

# Create a pricing recommendation function
def recommend_price(property_features, model, scaler):
    # Scale the features
    scaled_features = scaler.transform([property_features])

    # Predict the base price
    base_price = model.predict(scaled_features)[0]

    # Calculate price ranges
    conservative_price = base_price * 0.95
    aggressive_price = base_price * 1.05

    return {
        'conservative_price': conservative_price,
        'recommended_price': base_price,
        'aggressive_price': aggressive_price
    }

# Example of using the model to recommend prices
print("\nExample: Price recommendations for sample properties")

# Create sample properties
sample_indices = X_test.index[:3]
for i, idx in enumerate(sample_indices):
    sample_features = X.loc[idx].values
    price_recommendations = recommend_price(sample_features, seller_model, scaler)
    actual_price = y.loc[idx]

    print(f"\nSample Property {i+1}:")
    print(f"Conservative Price: ${price_recommendations['conservative_price']:,.2f}")
    print(f"Recommended Price: ${price_recommendations['recommended_price']:,.2f}")
    print(f"Aggressive Price: ${price_recommendations['aggressive_price']:,.2f}")
    print(f"Actual Sale Price: ${actual_price:,.2f}")